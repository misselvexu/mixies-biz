/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.biz.process;

import sirius.biz.process.logs.ProcessLog;
import sirius.kernel.async.CallContext;
import sirius.kernel.async.SubContext;
import sirius.kernel.async.TaskContext;
import sirius.kernel.commons.Producer;
import sirius.kernel.commons.Strings;
import sirius.kernel.commons.UnitOfWork;
import sirius.kernel.health.ExceptionHint;
import sirius.kernel.health.Exceptions;
import sirius.kernel.health.HandledException;
import sirius.kernel.health.Log;
import sirius.kernel.nls.NLS;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;

/**
 * Provides a local context to enhance error messages (mostly within {@link sirius.biz.jobs.batch.BatchJob jobs}).
 * <p>
 * When importing data (especially for complex files like XML), the error messages generated by <tt>sirius-db</tt>
 * are often not concise enough. Therefore, we populate this error context to keep track which entity was modified
 * and which actual action as been attempted.
 */
public class ErrorContext implements SubContext {

    /**
     * Marks an error as enhanced.
     * <p>
     * We need to perform this, as most probably several layers wrap a <tt>perform</tt> block around
     * a piece of code. Still, we only want to enhance the error once with the most detailed context. Otherwise,
     * the context would be appended several times.
     */
    private static final ExceptionHint MESSAGE_ENHANCED = new ExceptionHint("error-context-message-enhanced");

    private final Map<String, String> context = new LinkedHashMap<>();

    /**
     * Reveals the context for the current thread.
     *
     * @return the current error context
     */
    public static ErrorContext get() {
        return CallContext.getCurrent().get(ErrorContext.class);
    }

    /**
     * Adds a value to the error context.
     *
     * @param label the name of the value (this will be {@link NLS#smartGet(String) auto translated}.
     * @param value the value to store
     * @return the extended context for fluent method calls
     */
    public ErrorContext withContext(String label, Object value) {
        if (Strings.isEmpty(label)) {
            return this;
        }
        if (Strings.isEmpty(value)) {
            this.context.remove(label);
        } else {
            this.context.put(label, NLS.toUserString(value));
        }

        return this;
    }

    /**
     * Removes the value with the given label from the context.
     *
     * @param label the label of the value to remove
     * @return the modified context for fluent method calls
     */
    public ErrorContext removeContext(String label) {
        return withContext(label, null);
    }

    /**
     * Adds the given value to the context, performs the given task and then removes the value again.
     *
     * @param label the name of the value (this will be {@link NLS#smartGet(String) auto translated}.
     * @param value the value to store
     * @param task  the task to perform while the value is set
     * @return the context for fluent method calls
     * @throws Exception any error as thrown by the given task. Note that the exceptions are not handled and also
     *                   not automatically {@link #enhanceMessage(String) enhanced}.
     */
    public ErrorContext inContext(String label, Object value, UnitOfWork task) throws Exception {
        withContext(label, value);
        try {
            task.execute();
        } finally {
            removeContext(label);
        }

        return this;
    }

    /**
     * Obtains the current context as string.
     *
     * @return the current error context as string
     */
    public String getContextAsString() {
        return context.entrySet()
                      .stream()
                      .map(entry -> NLS.smartGet(entry.getKey()) + ": " + entry.getValue())
                      .collect(Collectors.joining(", "));
    }

    /**
     * Executes the given supplied and handles / {@link #enhanceMessage(String) enhances} all thrown errors.
     *
     * @param failureDescription annotates a given error message so that the user is notified what task actually went
     *                           wrong. This should be in "negative form" like "Cannot perform x because: message" as
     *                           it is only used for error reporting.
     * @param producer           the producer to execute
     * @return an optional containing the object returned by the supplier or an empty optional if exceptions happened during execution
     */
    public <T> Optional<T> performAndGet(UnaryOperator<String> failureDescription, Producer<T> producer) {
        try {
            return Optional.ofNullable(producer.create());
        } catch (HandledException exception) {
            logException(failureDescription, exception);
        } catch (Exception exception) {
            String message = exception.getMessage() + " (" + exception.getClass().getName() + ")";
            logException(failureDescription,
                         Exceptions.handle()
                                   .to(Log.BACKGROUND)
                                   .error(exception)
                                   .withDirectMessage(failureDescription.apply(message))
                                   .hint(MESSAGE_ENHANCED, true)
                                   .handle());
        }
        return Optional.empty();
    }

    private void logException(UnaryOperator<String> failureDescription, HandledException exception) {
        if (TaskContext.get().getAdapter() instanceof ProcessContext) {
            ((ProcessContext) TaskContext.get().getAdapter()).log(ProcessLog.error()
                                                                            .withMessage(enhanceMessage(
                                                                                    failureDescription.apply(exception.getMessage()))));
        } else {
            TaskContext.get().log(enhanceMessage(failureDescription.apply(exception.getMessage())));
        }
    }

    /**
     * Enhances the given error message by appending the current content.
     *
     * @param errorMessage the message to enhance
     * @return the enhanced error message
     */
    public String enhanceMessage(String errorMessage) {
        String contextAsString = getContextAsString();
        if (Strings.isFilled(contextAsString)) {
            return errorMessage + " (" + contextAsString + ")";
        } else {
            return errorMessage;
        }
    }

    /**
     * Performs the given task and handles / {@link #enhanceMessage(String) enhances} all thrown errors.
     *
     * @param failureDescription annotates a given error message so that the user is notified what task actually went
     *                           wrong. This should be in "negative form" like "Cannot perform x because: message" as
     *                           it is only used for error reporting.
     * @param task               the task to actually perform
     */
    public void perform(UnaryOperator<String> failureDescription, UnitOfWork task) {
        performAndGet(failureDescription, () -> {
            task.execute();
            return null;
        });
    }

    /**
     * Performs the given task and directly logs any occurring error.
     * <p>
     * Most probably, using {@link #perform(UnaryOperator, UnitOfWork)} is a better idea, as it permits to provide
     * more context to what actually went wrong.
     *
     * @param task the task to perform
     */
    public void perform(UnitOfWork task) {
        perform(UnaryOperator.identity(), task);
    }

    /**
     * Executes the given supplier and directly reports any occurring error.
     * <p>
     * Most probably, using {@link #performAndGet(UnaryOperator, Producer)} is a better idea, as it permits to provide
     * more context to what actually went wrong.
     *
     * @param producer the producer to execute
     * @return an optional containing the object returned by the supplier or an empty optional if exceptions happened during execution
     */
    public <T> Optional<T> performAndGet(Producer<T> producer) {
        return performAndGet(UnaryOperator.identity(), producer);
    }

    /**
     * Performs the given task as "import" of the given entity.
     * <p>
     * This will report a canned error message if the task fails.
     *
     * @param entityDescriptor the name or label which identifies the entity being imported. When in doubt, use
     *                         <tt>entity::toString</tt>.
     * @param task             the import task to perform
     */
    public void performImport(Supplier<String> entityDescriptor, UnitOfWork task) {
        perform(message -> NLS.fmtr("ErrorContext.importError")
                              .set("message", message)
                              .set("entity", entityDescriptor.get())
                              .format(), task);
    }

    /**
     * Performs the given task "deleting" the given entity.
     * <p>
     * This will report a canned error message if the task fails.
     *
     * @param entityDescriptor the name or label which identifies the entity being deleted. When in doubt, use
     *                         <tt>entity::toString</tt>.
     * @param task             the import task to perform
     */
    public void performDelete(Supplier<String> entityDescriptor, UnitOfWork task) {
        perform(message -> NLS.fmtr("ErrorContext.deleteError")
                              .set("message", message)
                              .set("entity", entityDescriptor.get())
                              .format(), task);
    }

    @Override
    public SubContext fork() {
        ErrorContext fork = new ErrorContext();
        fork.context.putAll(this.context);
        return fork;
    }

    @Override
    public void detach() {
        context.clear();
    }
}
